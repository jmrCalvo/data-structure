<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Nmer: Ejemplo de uso del TDA Ktree: genData</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Nmer: Ejemplo de uso del TDA Ktree
   &#160;<span id="projectnumber">V1</span>
   </div>
   <div id="projectbrief">TDA Ktree: Arbol general donde cada nodo tiene [0:k-1] hijos</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generado por Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Buscar');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Página&#160;principal</span></a></li>
      <li><a href="pages.html"><span>Páginas&#160;relacionadas</span></a></li>
      <li><a href="annotated.html"><span>Clases</span></a></li>
      <li><a href="files.html"><span>Archivos</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Buscar" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">genData </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Tabla de contenidos</h3>
<ul><li class="level1"><a href="#NOTA">NOTA IMPORTANTE</a></li>
<li class="level1"><a href="#generar">Generar Documentación</a></li>
<li class="level1"><a href="#intro_sec">Introducción</a></li>
<li class="level1"><a href="#Nmer">Implementación del TDA Nmer.</a></li>
<li class="level1"><a href="#secKtree">Árboles ktree</a><ul><li class="level2"><a href="#tdaktree">TDA ktree&lt;T,K&gt;</a></li>
<li class="level2"><a href="#implem">Implementación</a></li>
</ul>
</li>
<li class="level1"><a href="#ktreegen">Representando un Nmer como un ktree</a><ul><li class="level2"><a href="#rep">Representación</a></li>
</ul>
</li>
<li class="level1"><a href="#otrosMetodos">¿Cómo implementar algunos de los métodos en Nmer?</a><ul><li class="level2"><a href="#crear">Método 1 -&gt;  Nmer::sequenceADN(tama, adn) : Obteniendo los Nmers a partir de una cadena de ADN</a></li>
<li class="level2"><a href="#load">Método 2 -&gt;  Nmer::loadSerialized(nombre)</a></li>
<li class="level2"><a href="#rare">Método 3 -&gt; set&lt;pair&lt;string,int&gt;,OrdenCre &gt; Nmer::rareNmer(threshold)</a></li>
<li class="level2"><a href="#common">Método 4 -&gt;  set&lt;pair&lt;string,int&gt;,ordenDecre &gt; commonNmer(threshold)</a></li>
<li class="level2"><a href="#level">Método 5 -&gt; set&lt;pair&lt;string,int&gt;, ordenCrec &gt; level(l);</a></li>
<li class="level2"><a href="#problemaBiologia">Método 6 -&gt; float Distance(Nmer) : Aplicación del TDA Nmer a la caracterización del genoma de distintas especies.</a><ul><li class="level3"><a href="#dist">Cálculo de la Distancia</a></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><a href="#entrega">Entrega</a></li>
<li class="level1"><a href="#bibliografia">Bibliografía</a></li>
</ul>
</div>
<div class="textblock"><dl class="section version"><dt>Versión</dt><dd>v1 </dd></dl>
<dl class="section author"><dt>Autor</dt><dd>Juan F. Huete y Carlos Cano</dd></dl>
<h1><a class="anchor" id="NOTA"></a>
NOTA IMPORTANTE</h1>
<p>Esta práctica es individual, por lo que el alumno debe incluir una nota en la misma indicando que no ha utilizado material de otros compañeros o compañeras para su resolución.</p>
<p>En esta práctica deben serguirse los principios de compilación separada para las clases que no utilicen templates.</p>
<p>El alumno podrá dotar al tipo de dato de otros métodos que considere necesarios para la correcta realización de la práctica, pero debe respetar escrupulosamente la cabecera de los métodos detallados en este documento.</p>
<h1><a class="anchor" id="generar"></a>
Generar Documentación</h1>
<p>La práctica se entrega con un fichero pdf que contiene toda documentación así como un fichero .zip que contiene todos los ficheros necesarios para su realización. Al descomprimir el fichero nos encontraremos con un fichero Makefile y los siguientes directorios:</p>
<ul>
<li>bin &lt;&ndash; Directorio de ejecutables </li>
<li>datos &lt;&ndash; Directorio donde se encuentran los ficheros de datos necesarios para la correcta ejecución de la misma </li>
<li>doc &lt;&ndash; Directorio para la documentación de la práctia </li>
<li>include &lt;&ndash; Donde se incluyen los ficheros cabecera .h, </li>
<li>lib &lt;&ndash; Directorio de bibliotecas </li>
<li>obj &lt;&ndash; Directorio de código objeto </li>
<li>src &lt;&ndash; Donde se localizan los fuentes</li>
</ul>
<p>Para generar la documentación es necesario ejecutar </p><div class="fragment"><div class="line">make documentacion</div></div><!-- fragment --><p>como resultado tendremos que la documentación (en versión html) se generará en el directorio <code>doc/html</code> y en versión latex se genera en <code>doc/latex</code>.</p>
<p>Para obtener el ejecutable podemos hacer</p>
<div class="fragment"><div class="line">make clean</div><div class="line">make</div></div><!-- fragment --><p> que nos generá el ejecutable en el directorio <code>bin</code>, que podremos ejecutar </p><div class="fragment"><div class="line">cd bin</div><div class="line">./ejemploKtree</div></div><!-- fragment --><h1><a class="anchor" id="intro_sec"></a>
Introducción</h1>
<p>Un n-mer o n-grama se define como todas las posibles subcadenas de longitud n contenidas en una cadena [1]. En genética computacional, los n-mers son todas las posibles subsecuencias (de longitud igual a n) de una cadena de ADN (donde los nucleótidos posibles son A, G, C, T). El número máximo de n-mers diferentes de longitud n en una cadena de ADN será pues de 4^n.</p>
<p>El siguiente ejemplo muestra una lista de n-mers (para la longitud n especificada) obtenida de una secuencia de ADN: </p><div class="fragment"><div class="line">Secuencia:     AGATCGAGTG</div><div class="line">3-mers: AGA GAT ATC TCG CGA GAG AGT GTG</div><div class="line"></div><div class="line">Secuencia :     GTAGAGCTGTAG</div><div class="line">5-mers: GTAGA TAGAG AGAGC GAGCT AGCTG GCTGT CTGTA TGTAG</div></div><!-- fragment --><p>El conteo de n-mers para una secuencia de ADN es de especial interés en genética computacional porque estudios científicos muestran que estas distribuciones de n-mers caracterizan la especie a la que pertenece ese ADN (ver, por ejemplo, [2]). Es decir, a partir del conteo de n-mers de una secuencia de ADN dada (si la secuencia es lo bastante larga y el valor de n es suficientemente elevado), podríamos identificar la especie de la que procede ese ADN.</p>
<p>El problema del conteo de n-mers para una secuencia de ADN se puede definir como recontar cuántas veces aparece cada n-mer en la secuencia. En nuestro caso, nos interesará recontar cuántas veces aparece cada n-mer de longitud 1,2,...,n en la secuencia, es decir, para un valor dado de n, contaremos la frecuencia de sus 1-mers, 2-mers, 3-mers, ... , hasta n-mers. El siguiente ejemplo muestra el conteo de n-mers de longitud 1 hasta 5 en una secuencia de ADN: </p><div class="fragment"><div class="line">Secuencia :     GTAGAGCTGTAG</div><div class="line">1-mers: G:5 T:3 A:3 C:1</div><div class="line">2-mers: GT:2 TA:2 AG:3 GA:1 GC:1 CT:1 TG:1</div><div class="line">3-mers: GTA:2 TAG:2 AGA:1 GAG:1 AGC:1 GCT:1 CTG:1 TGT:1</div><div class="line">4-mers: GTAG:2 TAGA:1 AGAG:1 GAGC:1 AGCT:1 GCTG: 1 CTGT:1 TGTA:1</div><div class="line">5-mers: GTAGA:1 TAGAG:1 AGAGC:1 GAGCT:1 AGCTG:1 GCTGT:1 CTGTA:1 TGTAG:1</div></div><!-- fragment --><p>En esta práctica proponemos que el estudiante desarrolle el TDA <a class="el" href="classNmer.html">Nmer</a> para realizar el conteo de n-mers de longitud 1,2,...,n para una secuencia dada de ADN (ver sección <a class="el" href="index.html#Nmer">Implementación del TDA Nmer.</a>). Para ello, el estudiante debe utilizar el TDA ktree (ver sección <a class="el" href="index.html#ktreegen">Representando un Nmer como un ktree</a>). Una vez programado, el TDA <a class="el" href="classNmer.html">Nmer</a> se aplicará a la resolución de un problema real de biología computacional: se pondrán a disposición del estudiante secuencias reales de ADN de distintas especies, y el estudiante deberá determinar qué especies son más parecidas entre sí en base al recuento de los n-mers más frecuentes (ver sección <a class="el" href="index.html#problemaBiologia">Método 6 -&gt; float Distance(Nmer) : Aplicación del TDA Nmer a la caracterización del genoma de distintas especies.</a>).</p>
<h1><a class="anchor" id="Nmer"></a>
Implementación del TDA Nmer.</h1>
<p>La primera tarea a la que se enfrenta el estudiante es la implementación del TDA <a class="el" href="classNmer.html">Nmer</a>. Su especificación se detalla a continuación:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span><a class="code" href="classNmer.html">Nmer</a> {</div><div class="line">  <a class="code" href="classNmer.html#ac2a651dd05b03e716b877c26386d772e">Nmer</a>();</div><div class="line">  <a class="code" href="classNmer.html#ac2a651dd05b03e716b877c26386d772e">Nmer</a>(<span class="keyword">const</span> <a class="code" href="classNmer.html">Nmer</a> &amp; a);</div><div class="line"></div><div class="line">  </div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="classNmer.html#a1ce1c0cb174d94685c7234f58f9dc119">list_Nmer</a>( ) <span class="keyword">const</span>; <span class="comment">// lista todos los Nmer del árbol siguiendo un recorrido en preorden;</span></div><div class="line"></div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="classNmer.html#a60e2335600c01ee39e865790015818f0">length</a>() <span class="keyword">const</span>; <span class="comment">// Devuelve la longitud máxima de los Nmers almacenados</span></div><div class="line"></div><div class="line">  <a class="code" href="classNmer.html#a1b8892df885de3ac91edf3abd8f1b55d">size_type</a> <a class="code" href="classNmer.html#accdea65838fcd53c48a2d05f6809643f">size</a>() <span class="keyword">const</span>; <span class="comment">// Devuelve el número de Nmers distintos almacenados</span></div><div class="line"></div><div class="line">  <a class="code" href="classNmer.html">Nmer</a> &amp;  <a class="code" href="classNmer.html#a129843cfe04a63a199ac641117c052cc">operator=</a>(<span class="keyword">const</span> <a class="code" href="classNmer.html">Nmer</a> &amp; a);  <span class="comment">// operador de asignacion</span></div><div class="line"></div><div class="line">  <a class="code" href="classNmer.html">Nmer</a> <a class="code" href="classNmer.html#adf184ca659cf3ce3f2db301acae40e56">Prefix</a>(<span class="keywordtype">string</span> adn); <span class="comment">// Devuelve el Nmer (subarbol) asociado a un prefijo. Por ejemplo, si adn es &quot;ACT&quot;, devuelve el Nmer que representa todas las subcadenas que empiezan por &quot;ACT&quot; (ACT*)</span></div><div class="line"></div><div class="line">  <a class="code" href="classNmer.html">Nmer</a> <span class="keyword">union</span>(<span class="keyword">const</span> <a class="code" href="classNmer.html">Nmer</a> reference);<span class="comment">// Se devuelve un Nmer donde para cada nodo (representa una secuencia) se computa la suma de las frecuencias en *this y en referencia, </span></div><div class="line"></div><div class="line">  <span class="keywordtype">bool</span> <a class="code" href="classNmer.html#a3aa6c3d317ab01bd6b8c53434f50d03f">containsString</a>(<span class="keyword">const</span> <span class="keywordtype">string</span> adn) <span class="keyword">const</span>; <span class="comment">// Devuelve true si la cadena adn está representada en el árbol. </span></div><div class="line"></div><div class="line">  <span class="keywordtype">bool</span> <a class="code" href="classNmer.html#ac5af1362b3f8ef4141574e62bc3510ac">included</a>(<span class="keyword">const</span> <a class="code" href="classNmer.html">Nmer</a> reference) <span class="keyword">const</span>; <span class="comment">// Devuelve true si cada nodo de *this está también representado en reference, es decir, si todas las secuencias representadas en el árbol de *this están también incluidas en reference. False en otro caso.</span></div><div class="line"></div><div class="line">  ...</div><div class="line"> </div><div class="line">  <span class="comment">//El resto de cabeceras se describe en otra sección de este documento: </span></div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="classNmer.html#ae8871242f0e282d71e4c9b4685f468be">sequenceADN</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> l, <span class="keyword">const</span> <span class="keywordtype">string</span> &amp; adn);  </div><div class="line"></div><div class="line">  <span class="keywordtype">bool</span> <a class="code" href="classNmer.html#a418c016bb6e04d2f699ddb694ee0221f">loadSerialized</a>(<span class="keyword">const</span> <span class="keywordtype">string</span> nombre_fichero);</div><div class="line"> </div><div class="line">  <span class="keywordtype">float</span>  <a class="code" href="classNmer.html#a8df2f2f355423b02413e5e29dc5639e8">Distance</a>(<span class="keyword">const</span> <a class="code" href="classNmer.html">Nmer</a> &amp; x);</div><div class="line"></div><div class="line">  set&lt;pair&lt;string,int&gt;,OrdenCre &gt; <a class="code" href="classNmer.html#ac878556843a4b401b4be0e1be6747e45">rareNmer</a>(<span class="keywordtype">int</span> threshold); </div><div class="line"></div><div class="line">  set&lt;pair&lt;string,int&gt;,ordenDecre &gt; <a class="code" href="classNmer.html#aaf801908e364dd05d7cc33c81d944b0a">commonNmer</a>(<span class="keywordtype">int</span> threshold);</div><div class="line"></div><div class="line">  set&lt;pair&lt;string,int&gt;, ordenCrec &gt; <a class="code" href="classNmer.html#a38059ff69b4934e18a5c467338179761">level</a>(<span class="keywordtype">int</span> l);</div><div class="line"></div><div class="line">  ...</div><div class="line">}</div></div><!-- fragment --><p>El alumno podrá dotar al tipo de dato de otros métodos que considere necesarios para la correcta realización de la práctica, pero debe respetar escrupulosamente la cabecera de los métodos detallados anteriormente.</p>
<p>Para la implementación del TDA <a class="el" href="classNmer.html">Nmer</a> debemos hacer uso de TDA ktree (ver sección <a class="el" href="index.html#ktreegen">Representando un Nmer como un ktree</a>).</p>
<h1><a class="anchor" id="secKtree"></a>
Árboles ktree</h1>
<p>Una de las desventajas de usar un vector o lista enlazada para almacenar datos es el tiempo necesario para buscar un elemento. Puesto que tanto vectores como listas enlazadas son estructuras lineales, el tiempo requerido para buscar una lista "lineal" es proporcional al tamaño del conjunto de datos, esto es O(n). Una alternativa para resolver este problema es considerar un conjunto ordenado de elementos, pero igualmente ambas estructuras tienen comportamiento ineficiente cuando tenemos que abordar las tareas de inserción y borrado de elementos (O(n)).</p>
<p>Este comportamiento no es aceptable en el mundo de hoy, donde la velocidad a la que realizamos las operaciones es extremadamente importante. El tiempo es dinero. Por lo tanto, parece que se necesitan estructuras de datos mejores (más eficientes) para almacenar y buscar datos.</p>
<p>En esta práctica analizaremos cómo una estructura de datos árbol nos puede ayudar a resolver algunos de nuestros problemas. Un árbol es una colección de nodos conectados formando una estructura jerárquica (y por tanto no lineal) donde para cada nodo tiene un único padre y una lista de hijos.</p>
<p>En principio, un nodo puede tener un número indeterminado de hijos, hablamos de árboles generales, pero en esta práctica nos centraremos en el estudio de un tipo particular de árboles, que denominaremos ktree&lt;T,K&gt; y que tiene la siguiente características:</p>
<ul>
<li>Un nodo tiene entre 0 y k hijos, que se ubican en una posición dada por un índice, así hablamos del j-ésimo hijo, con 0&lt;= j &lt; k </li>
<li>Por ser un árbol, cada nodo del mismo tiene un único padre. </li>
<li>Que exista el hijo j-ésimo no implica que tengan que existir los hijos anteriores, esto es, si k = 10 puede ocurrir que un nodo tenga los hijos segundo, quinto y séptimo. El resto de sus descendientes pueden estar vacíos.</li>
</ul>
<h2><a class="anchor" id="tdaktree"></a>
TDA ktree&lt;T,K&gt;</h2>
<p>Se ha diseñado un TDA ktree (la documentación está adjunta con esta práctica). El tipo ktree tiene dos parámetros plantilla, ktree&lt;T,K&gt;, donde T representa al tipo de dato que se almacena en el nodo y K es un entero que representa el número máximo de hijos que se permiten en cada nodo. Es constante para todo el tipo.</p>
<p>Por ejemplo:</p>
<div class="fragment"><div class="line"><a class="code" href="classktree.html">ktree&lt;int,4&gt;</a> a; <span class="comment">// árbol de enteros con 4 hijos como máximo</span></div><div class="line"><a class="code" href="classktree.html">ktree&lt;string,7&gt;</a> b; <span class="comment">// árbol de cadenas con 7 hijos como máximo</span></div><div class="line"><a class="code" href="classktree.html">ktree&lt;int,2&gt;</a> c; <span class="comment">//árbol de enteros con 2 hijos como máximo (es un árbol binario)</span></div></div><!-- fragment --><p>Indicar que a y c pertenecen a tipos distintos, esto es ktree&lt;int,4&gt; es un tipo distinto de ktree&lt;int,2&gt;.</p>
<p>Cuando trabajamos con el TDA ktree tenemos definidos los siguientes </p><ul>
<li>ktree&lt;T,K&gt; -&gt; Representa el árbol </li>
<li>ktree&lt;T,K&gt;::node -&gt; Representa un nodo del árbol </li>
<li>ktree&lt;T,K&gt;::const_node -&gt; Representa un nodo constante del árbol (no podemos modificar su contenido) </li>
<li><a class="el" href="classktree_1_1node.html#afa2e7c16e38c1a4a062930d167b02a7f">ktree&lt;T,K&gt;::node::child_iterator</a> -&gt; Iterador sobre los hijos (no nulos) de un nodo </li>
<li><a class="el" href="classktree_1_1const__node.html#afa2e7c16e38c1a4a062930d167b02a7f">ktree&lt;T,K&gt;::const_node::child_iterator</a> -&gt; Iterador sobre los hijos (no nulos) de un nodo constante</li>
</ul>
<p>Así por ejemplo, la figura siguiente representa un ktree&lt;char,5&gt;</p>
<div class="image">
<img src="ktree_ejemplo.jpg" alt="ktree_ejemplo.jpg"/>
</div>
 <div class="fragment"><div class="line"><a class="code" href="classktree.html">ktree&lt;char,5&gt;</a> arbol;</div><div class="line"><a class="code" href="classktree_1_1node.html">ktree&lt;char,5&gt;::node</a> n, nodo;</div><div class="line">n = arbol.<a class="code" href="classktree.html#a2d252651d05d9a107c009fcfdfc91df4">root</a>();</div><div class="line">cout &lt;&lt; *n <span class="comment">// Nos imprime A</span></div><div class="line">nodo = n.<a class="code" href="classktree_1_1node.html#adcb69c2caed252b51d400f4237c1f472">k_child</a>(4); <span class="comment">// &lt;- Apunta al nodo con etiqueta D</span></div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<a class="code" href="classktree_1_1node_1_1child__iterator.html">ktree&lt;char,5&gt;::node::child_iterator</a> ith : n)</div><div class="line">  cout&lt;&lt; *(*ith) &lt;&lt; endl; <span class="comment">// &lt;--  Imprime los hijos no nulos de n, esto es B,C,D</span></div><div class="line">                              <span class="comment">//  *ith es el nodo hijo, *(*ith) es la etiqueta que hay dentro de dicho nodo.</span></div></div><!-- fragment --><p>Con el guión se entrega un código que ilustra el uso de ktree para distintos problemas (fichero <code><a class="el" href="ejemploKtree_8cpp.html">ejemploKtree.cpp</a></code>), como por ejemplo recorridos, cálculo de la altura de un ktree, inserción en un árbol binario de búsqueda representado mediante un ktree&lt;int,2&gt;, etc.</p>
<p>Este código, una vez compilado, debe ejecutarse desde la carpeta <code>bin</code>:</p>
<div class="fragment"><div class="line">cd bin </div><div class="line">./ejemploKtree </div></div><!-- fragment --><h2><a class="anchor" id="implem"></a>
Implementación</h2>
<p>Puesto que conocemos el número máximo de hijos de un nodo, fijo en todo momento, podemos acceder a ellos considerando un acceso aleatorio. Esto es consultar el hijo j-ésimo en orden constante. Para ello, se implementa un nodo usando la siguiente estructura,</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>celdaArbol {</div><div class="line">  T etiqueta;</div><div class="line">  celdaArbol * padre;</div><div class="line">  celdaArbol * hijos[K];</div><div class="line">};</div></div><!-- fragment --><p>donde </p><ul>
<li>etiqueta representa a la etiqueta almacenada en el nodo </li>
<li>padre es un puntero a la celdaArbol que contiene al padre de dicho nodo </li>
<li>hijos es un array de tamaño fijo, K, donde en cada posición almacenamos un puntero al hijo j-ésimo (0&lt;=j&lt;K) del nodo en el árbol</li>
</ul>
<p>Considerando esta información un árbol ktree se implementará como un puntero a la celda que contiene el nodo raíz del mismo.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keywordtype">int</span> K&gt; </div><div class="line"><span class="keyword">class </span><a class="code" href="classktree.html">ktree</a> {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">   <a class="code" href="classktree.html#a70c8511d0c0fc199f341065fab0aa0ad">ktree</a>();</div><div class="line">   ....</div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    celdaArbol * laraiz;</div><div class="line">};</div></div><!-- fragment --><p>Como hemos comentado el TDA ktree contiene los siguientes tipos definidos</p>
<ul>
<li>ktree&lt;T,K&gt;::node -&gt; Representa un nodo del árbol </li>
<li>ktree&lt;T;K&gt;::const_node -&gt; Representa un nodo constante (no podemos modificar su contenido) en el árbol</li>
</ul>
<p>Donde para cada nodo (node o const_node), su representación interna no será mas que un puntero a la celda del árbol a la que apunta, diferenciándose en el tipo de operaciones (especificación) que permiten realizar sobre el mismo (ver documentación asociada).</p>
<p>Si consideramos los iteradores, esto es,</p>
<ul>
<li><a class="el" href="classktree_1_1node.html#afa2e7c16e38c1a4a062930d167b02a7f">ktree&lt;T,K&gt;::node::child_iterator</a> -&gt; Iterador sobre los hijos no nulos de un nodo </li>
<li><a class="el" href="classktree_1_1const__node.html#afa2e7c16e38c1a4a062930d167b02a7f">ktree&lt;T,K&gt;::const_node::child_iterator</a> -&gt; Iterador sobre los hijos no nulos de un nodo constante</li>
</ul>
<p>Ambos iteradores tienen una representación un poco más compleja, al considerar tanto el nodo sobre el que queremos iterar como el hijo en el que ubica en este momento.</p>
<p>La siguiente imagen ilustra la representación interna del ktree.</p>
<div class="image">
<img src="ktree_estructura.jpg" alt="ktree_estructura.jpg"/>
</div>
 <h1><a class="anchor" id="ktreegen"></a>
Representando un Nmer como un ktree</h1>
<h2><a class="anchor" id="rep"></a>
Representación</h2>
<p>Podemos representar todos los <a class="el" href="classNmer.html">Nmer</a> hasta una determinada longitud mediante un ktree. Para ello, en cada nodo se almacenará un char que representa a una base (A,G,C,T), excepto el nodo raíz que almacena un char nulo, por ejemplo '-'.</p>
<p>El camino que existe desde la raíz del ktree hasta un nodo n en el nivel l codificará una subsecuencia de bases consecutivas en la cadena de tamaño l. Por ejemplo, supongamos la cadena "ATACATCATTGTGG". Las distintas subsecuencias (de tamaños 1 a 3) que nos pueden aparecer son:</p>
<ul>
<li>Tamaño 1: A; G; C; T </li>
<li>Tamaño 2: AC; AT; GG; GT; CA; TA; TG; TC; TT </li>
<li>Tamaño 3: ACA; ATA; ATC; ATT; GTG; CAT; TAC; TGG; TGT; TCA; TTG</li>
</ul>
<p>Por tanto, cada nodo del árbol tendrá como máximo 4 descendientes director (hijos) que representan las posibles bases que pueden aparecer en la cadena para formar las subsecuencias de tamaño l+1, asociando cada uno a una base distinta de la siguiente forma</p>
<ul>
<li>A -&gt; hijo 0</li>
</ul>
<ul>
<li>G -&gt; hijo 1</li>
</ul>
<ul>
<li>C-&gt; hijo 2</li>
</ul>
<ul>
<li>T-&gt; hijo 3</li>
</ul>
<p>No olvidemos que, además de identificar las subsecuencias, estamos interesados el contar el número de veces que se repita cada una de ellas en la cadena. Para ello, es suficiente con incluir también en cada nodo del árbol un valor entero que codifique dicha información. Así, la clase <a class="el" href="classNmer.html">Nmer</a> se puede representar como se indica:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span><a class="code" href="classNmer.html">Nmer</a> {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    <a class="code" href="classNmer.html#ac2a651dd05b03e716b877c26386d772e">Nmer</a>();</div><div class="line">    ....</div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <a class="code" href="classktree.html">ktree&lt;pair&lt;char,int&gt;</a>,4&gt; el_Nmer; <span class="comment">// subsecuencias </span></div><div class="line">    <span class="keywordtype">int</span> max_long; <span class="comment">// Mayor longitud de la cadena representada, esto es, el nivel máximo del árbol</span></div><div class="line">  </div><div class="line"></div><div class="line">};</div></div><!-- fragment --><p>La siguiente figura muestra un subconjunto del árbol para una longitud de subcadena máxima de 3 (max_long = 3) que se obtiene cunado consideramos la cadena "ATACATCATTGTGG", la lista todas las posibles subcadenas (junto a su frecuencia es: A 4; AC 1; ACA 1; AT 3; ATA 1; ATC 1; ATT 1; C 2; CA 2; CAT 2; G 3; GG 1; GT 1; GTG 1; T 5; TA 1; TAC 1; TC 1; TCA 1; TG 2; TGG 1; TGT 1; TT 1; TTG 1).</p>
<div class="image">
<img src="ktree_cadena.jpg" alt="ktree_cadena.jpg"/>
</div>
 <h1><a class="anchor" id="otrosMetodos"></a>
¿Cómo implementar algunos de los métodos en Nmer?</h1>
<p>En esta sección presentaremos con mas detalle el comportamiento de algunos de los métodos de la clase <a class="el" href="classNmer.html">Nmer</a> que hay que implementar. Estos métodos permiten abordar distintos problemas de interés en genética computacional. Recordemos que son los métodos:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span><a class="code" href="classNmer.html">Nmer</a> {</div><div class="line">  ...</div><div class="line"></div><div class="line">  <span class="keyword">public</span>:</div><div class="line"></div><div class="line">   <span class="keywordtype">void</span> <a class="code" href="classNmer.html#ae8871242f0e282d71e4c9b4685f468be">sequenceADN</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> tama, <span class="keyword">const</span> <span class="keywordtype">string</span> &amp; adn);  <span class="comment">// Construir Nme a partir de cadena de ADN</span></div><div class="line"></div><div class="line">   <span class="keywordtype">bool</span> <a class="code" href="classNmer.html#a418c016bb6e04d2f699ddb694ee0221f">loadSerialized</a>(<span class="keyword">const</span> <span class="keywordtype">string</span> nombre_fichero); <span class="comment">// Leer fichero serializado que representa a un Nmer </span></div><div class="line"></div><div class="line">   set&lt;pair&lt;string,int&gt;,OrdenCre &gt; <a class="code" href="classNmer.html#ac878556843a4b401b4be0e1be6747e45">rareNmer</a>(<span class="keywordtype">int</span> threshold); <span class="comment">// devuelve la lista de todas las subcadenas (no prefijo) que  aparecen menos de threshold veces en el Nmer ordenadas en orden creciente de frecuencia</span></div><div class="line"></div><div class="line">   set&lt;pair&lt;string,int&gt;,ordenDecre &gt; <a class="code" href="classNmer.html#aaf801908e364dd05d7cc33c81d944b0a">commonNmer</a>(<span class="keywordtype">int</span> threshold); <span class="comment">// Devuelve la lista de las cadenas de longitud mayor posible (no prefijo)  que aparecen más de threshold veces en el Nmer, ordenadas en orden decreciente de frecuencia</span></div><div class="line">  </div><div class="line">   set&lt;pair&lt;string,int&gt;, ordenCrec &gt; <a class="code" href="classNmer.html#a38059ff69b4934e18a5c467338179761">level</a>(<span class="keywordtype">int</span> l); <span class="comment">// Devuelve el conjunto de Nmers de longitud exacta l.</span></div><div class="line"></div><div class="line">   <span class="keywordtype">float</span>  <a class="code" href="classNmer.html#a8df2f2f355423b02413e5e29dc5639e8">Distance</a>(<span class="keyword">const</span> <a class="code" href="classNmer.html">Nmer</a> &amp; x);  <span class="comment">// Distancia entre  dos Nmer</span></div><div class="line"></div><div class="line">  ...</div><div class="line">}</div></div><!-- fragment --><p>El alumno podrá dotar al tipo de dato de otros métodos que considere necesarios para la correcta realización de la práctica, pero debe respetar escrupulosamente la cabecera de los métodos detallados anteriormente.</p>
<h2><a class="anchor" id="crear"></a>
Método 1 -&gt;  Nmer::sequenceADN(tama, adn) : Obteniendo los Nmers a partir de una cadena de ADN</h2>
<p>El primer problema que nos tendremos que plantear a la hora de solucionar la práctica es el poder construir el ktree que representa los distintos Nmers. Como ya hemos comentado, utilizaremos un ktree con valor k=4, donde en cada nodo almacenamos no sólo la base, sino también su frecuencia dentro de la cadena de ADN. En cierto sentido, el nodo en el nivel i-ésimo representa un <a class="el" href="classNmer.html">Nmer</a> de longitud i (dicho <a class="el" href="classNmer.html">Nmer</a> se obtiene al considerar, en orden inverso, el camino que hay desde dicho nodo a la raíz del árbol). Recordad que en cada nodo almacenamos no sólo la base, sino también el contador que nos indica las ocurrencias del <a class="el" href="classNmer.html">Nmer</a> que representa el nodo en la secuencia de ADN.</p>
<p>En esta sección trataremos de ilustrar de forma detallada cómo podemos construir el árbol de Nmers (nuestro ktree) a partir de una secuencia de ADN. Para ello consideraremos dos métodos. El primero, sequenceADN, se encarga de recorrer la cadena de ADN para extraer una a una todas las subcadenas de longitud tama de las que se extraen los distintos Nmers a insertar. El segundo es un método privado, insertar_cadena, que, dada una subsecuencia de tamaño tama, se encarga de insertar los "tama" Nmers (subsecuencias que empiezan en cadena[0] y con longitud 1 hasta cadena.size()) en el árbol.</p>
<p>Por ejemplo, si adn = "ATACATCATTGTGG" y tama es 6, sequenceADN extraería las subsecuencias:</p>
<ul>
<li>"ATACAT"</li>
<li>"TACATC"</li>
<li>"ACATCA"</li>
<li>"CATCAT"</li>
<li>...</li>
</ul>
<p>En pseudo-código, sequenceADN podría implementarse como sigue:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="classNmer.html#ae8871242f0e282d71e4c9b4685f468be">Nmer::sequenceADN</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> tama, <span class="keyword">const</span> <span class="keywordtype">string</span> &amp; adn){</div><div class="line"></div><div class="line">  Inicializamos el árbol poniendo la  etiqueta (<span class="charliteral">&#39;-&#39;</span>,0) en el nodo raíz </div><div class="line"></div><div class="line">  Para cada uno de las posiciones, i,  de la cadena {</div><div class="line">    Obtenemos un substring de tamaño tama que empiece en adn[i];</div><div class="line">    insertar_cadena(subcadena);</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p>Si nos centramos en cada una de las cadenas, insertar_cadena permite considerar los Nmers que <b>empiezan</b> en cadena.begin(). Por ejemplo, considerando un tamaño hasta 6, los distintos Nmers para "ATACAT" considerados en este método serían:</p>
<ol type="1">
<li>"A"</li>
<li>"AT"</li>
<li>"ATA"</li>
<li>"ATAC"</li>
<li>"ATACA"</li>
<li>"ATACAT"</li>
</ol>
<p>El esquema del algoritmo insertar_cadena es el siguiente: avanzar por la cadena a la vez que descendemos por el árbol para actualizar los valores del <a class="el" href="classNmer.html">Nmer</a> que representa, como indica el siguiente pseudo-código:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> insertar_cadena(<span class="keyword">const</span> <span class="keywordtype">string</span> &amp; cadena){</div><div class="line"></div><div class="line">  posicionamos un nodo, n_act, en la raiz del arbol.</div><div class="line"></div><div class="line">  <span class="comment">//Este nodo n lo utilizamos para descender por el arbol</span></div><div class="line">  <span class="comment">// cadena[i] nos indica el índice del nodo en el  nivel i+1;</span></div><div class="line">  <span class="comment">// A -&gt; hijo 0; G -&gt; hijo 1; C-&gt; hijo 2; T-&gt; hijo 3</span></div><div class="line"></div><div class="line">  Para cada uno de los caracteres, i, de la cadena {</div><div class="line">    cadena[i] nos indica el índice del nodo en el  nivel i+1;</div><div class="line">    <span class="comment">// si cadena[i] es : A -&gt; hijo 0; G -&gt; hijo 1; C-&gt; hijo 2; T-&gt; hijo 3</span></div><div class="line">    si n_act tiene hijo en la posición dada por cadena[i] { <span class="comment">// Ya esta insertado el nodo</span></div><div class="line">      incrementamos el contador en 1;</div><div class="line">    }</div><div class="line">    en caso contrario { <span class="comment">//  No esta insertado el nodo</span></div><div class="line">        insertamos el nuevo nodo en dicha posición con etiqueda cadena[i] y su contador a 1;</div><div class="line">    }</div><div class="line">    descendemos en el árbol, haciendo que n_act sea el nodo que representa cadena[i], esto es bajamos al hijo correspondiente;</div><div class="line">  }</div><div class="line"></div><div class="line">}</div></div><!-- fragment --><p>Para finalizar, os entregamos el código que nos recorre el ktree en preorden, donde por ejemplo la acción sobre el hijo podría ser obtener el <a class="el" href="classNmer.html">Nmer</a> que representa el nodo. En este algoritmo, n será el nodo a partir del cual queremos realizar el recorrido en preorden:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="ejemploKtree_8cpp.html#a7ae38f4399966752d1ca1d20d24b63ac">recorrido_preorden</a>( <a class="code" href="classktree.html">ktree</a>&lt;pair&lt;char,int&gt;,4&gt;::node  n){</div><div class="line"></div><div class="line"><span class="keywordflow">if</span> (!n.null()){</div><div class="line">   &lt; accion sobre el nodo n &gt;</div><div class="line">   <span class="keywordflow">for</span> ( <a class="code" href="classktree_1_1node.html">ktree&lt;base,4&gt;::node</a> hijo : n)</div><div class="line">     <a class="code" href="ejemploKtree_8cpp.html#a7ae38f4399966752d1ca1d20d24b63ac">recorrido_preorden</a>(hijo);</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="load"></a>
Método 2 -&gt;  Nmer::loadSerialized(nombre)</h2>
<p>Por si el alumno tiene problema en la construcción del <a class="el" href="classNmer.html">Nmer</a>, se entrega este método ya implementado que, a partir de un fichero serializado (con extensión .srl), reconstruye el ktree que lo generó. Con la práctica se entregan algunos ejemplos de ficheros serializados que podrán ser utilizados por el alumno para obtener distintos objetos <a class="el" href="classNmer.html">Nmer</a> válidos (<code>datos/cadenaSimple.srl</code>, <code>datos/cadenabosTaurus.srl</code> o <code>datos/cadenamusMusculus.srl</code>).</p>
<p>De este modo, podemos utilizar este método para ir avanzando en la implementación de los otros métodos de la clase incluso antes de tener implementado el método que construye el <a class="el" href="classNmer.html">Nmer</a> a partir de una secuencia (método sequenceADN).</p>
<p>Un ejemplo de cómo poder utilizar este método lo podemos encontrar en el fichero <a class="el" href="ejemploKtree_8cpp.html">ejemploKtree.cpp</a>:</p>
<div class="fragment"><div class="line"><a class="code" href="classNmer.html">Nmer</a> prueba;</div><div class="line">prueba.<a class="code" href="classNmer.html#a418c016bb6e04d2f699ddb694ee0221f">loadSerialized</a>(<span class="stringliteral">&quot;cadenaSimple.srl&quot;</span>);</div><div class="line">cout &lt;&lt; prueba.<a class="code" href="classNmer.html#a60e2335600c01ee39e865790015818f0">length</a>(); <span class="comment">// devuelve 3</span></div><div class="line">cout &lt;&lt; prueba.<a class="code" href="classNmer.html#accdea65838fcd53c48a2d05f6809643f">size</a>(); <span class="comment">// devuelve 24</span></div><div class="line">prueba.<a class="code" href="classNmer.html#a1ce1c0cb174d94685c7234f58f9dc119">list_Nmer</a>();  <span class="comment">// Listaria todos los Nmers (desde longitud 1 hasta longitud prueba.length()</span></div></div><!-- fragment --><p>Sólo a nivel informativo, indicar que para poder reconvertir el fichero serializado necesitamos de un functor que nos permita transformar un string del tipo "A 45" o "x -1", donde el primer elemento de la cadena es un char y el segundo un entero, en un objeto de tipo pair&lt;char,int&gt;. Dicho functor, se encuentra dentro de la parte privada de la clase <a class="el" href="classNmer.html">Nmer</a> con el nombre String2Base.</p>
<p>El código para loadSerialized (ya incluido en el <code><a class="el" href="Nmer_8cpp.html">Nmer.cpp</a></code>) es el siguiente:</p>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> <a class="code" href="classNmer.html#a418c016bb6e04d2f699ddb694ee0221f">Nmer::loadSerialized</a>(<span class="keyword">const</span> <span class="keywordtype">string</span> &amp; fichero) {</div><div class="line"> <span class="keywordtype">string</span> cadena;</div><div class="line"> ifstream fe;</div><div class="line"> pair&lt;char,int&gt; nulo(<span class="charliteral">&#39;x&#39;</span>,-1);</div><div class="line"> Nmer::String2Base stb;</div><div class="line"> </div><div class="line"> fe.open(fichero.c_str(), ifstream::in);</div><div class="line">   <span class="keywordflow">if</span> (fe.fail()){</div><div class="line">     cerr &lt;&lt; <span class="stringliteral">&quot;Error al abrir el fichero &quot;</span> &lt;&lt; fichero &lt;&lt; endl;</div><div class="line">   } </div><div class="line">   <span class="keywordflow">else</span> {</div><div class="line">    <span class="comment">//leo la cabecera del fichero (líneas que comienzan con #)</span></div><div class="line">    <span class="keywordflow">do</span>{ </div><div class="line">      getline(fe,cadena,<span class="charliteral">&#39;\n&#39;</span>); </div><div class="line">    } <span class="keywordflow">while</span> (cadena.find(<span class="stringliteral">&quot;#&quot;</span>)==0 &amp;&amp; !fe.eof());</div><div class="line">    <span class="comment">// leemos Nmer_length</span></div><div class="line">     max_long = std::stoi(cadena);</div><div class="line">     <span class="comment">// leemos cadena serializada</span></div><div class="line">    getline(fe,cadena,<span class="charliteral">&#39;\n&#39;</span>);</div><div class="line">    el_Nmer.<a class="code" href="classktree.html#a66d27ffb43b3c790370b45c0a8309534">deserialize</a>(cadena,nulo,<span class="charliteral">&#39;;&#39;</span>,stb); </div><div class="line">    fe.close();</div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">  } <span class="comment">// else</span></div><div class="line">  fe.close();</div><div class="line">  <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"> }</div></div><!-- fragment --><h2><a class="anchor" id="rare"></a>
Método 3 -&gt; set&lt;pair&lt;string,int&gt;,OrdenCre &gt; Nmer::rareNmer(threshold)</h2>
<p>Este método devuelve el conjunto de subcadenas (no prefijo) que aparecen un número de veces menor o igual a threshold veces en el <a class="el" href="classNmer.html">Nmer</a>. Cada cadena se almacenará en el primer campo del par, mientras que en el segundo dispondremos de la frecuencia de aparición de la cadena. El conjunto deberá estar ordenado en orden creciente de frecuencia, esto es, la cadena menos frecuente aparecerá la primera en el set (esto resulta de utilidad, por ejemplo, para buscar peculiaridades en la secuencia de ADN).</p>
<p><b>¿Qué es una cadena prefijo?:</b> decimos que una cadena, x, es prefijo de otra, y, si x está completamente incluida en y empezando desde el principio. Por ejemplo x="abcde" es prefijo de "abcdefg" pero no lo es de "sabcdefg".</p>
<p>Por tanto, si realizamos una llamada al método rareNmer(4), threshold vale 4, y encontramos que el <a class="el" href="classNmer.html">Nmer</a> "AC" aparece 5 veces, el <a class="el" href="classNmer.html">Nmer</a> "ACG" aparece 4 veces, el <a class="el" href="classNmer.html">Nmer</a> "ACGG" aparece 2 y "ACGT" aparece 1, la salida de rareNmer sólo debería devolver "ACGG" y "ACGT", pues "ACG", aun teniendo una frecuencia menor o igual que el threshold 4, es prefijo de otra cadena de longitud mayor que ya se devuelve como resultado.</p>
<h2><a class="anchor" id="common"></a>
Método 4 -&gt;  set&lt;pair&lt;string,int&gt;,ordenDecre &gt; commonNmer(threshold)</h2>
<p>Devuelve el conjunto de las subcadenas de longitud mayor posible (sin ser prefijo) que aparecen un número de veces mayor que de threshold veces en el <a class="el" href="classNmer.html">Nmer</a>, ordenadas en orden decreciente de frecuencia (se utiliza para buscar repeticiones mas comunes, por ejemplo cuando tratamos de comprimir una cadena de ADN). Al igual que antes, el conjunto de cadenas deberá estar ordenado, pero en este caso en orden decreciente, esto es, aparecen primero las maś frecuentes.</p>
<p>Por ejemplo, si consideramos que un <a class="el" href="classNmer.html">Nmer</a> contiene a "AC" que aparece 5 veces, a "AT" que aparece 5 veces, a "ACG" que aparece 4 veces, "ACT" que aparece 4 veces, "ATG" que aparece 3 veces "ACGG" que aparece 2 y "ACGT" que aparece 1, una llamada a <code>commonNmer(3)</code> dará como salida "AT", "ACG" y "ACT". En este caso "AC", aun teniendo una frecuencia mayor que el threshold 4, es prefijo de otra cadena de longitud mayor que ya se devuelve como resultado.</p>
<h2><a class="anchor" id="level"></a>
Método 5 -&gt; set&lt;pair&lt;string,int&gt;, ordenCrec &gt; level(l);</h2>
<p>Este método nos devuelve únicamente los Nmers de longitud l, ordenados en orden creciente de frecuencia.</p>
<p>Por ejemplo, si consideramos que un <a class="el" href="classNmer.html">Nmer</a> contiene a "AC" que aparece 5 veces, a "AT" que aparece 5 veces, a "ACG" que aparece 4 veces, "ACT" que aparece 4 veces, "ATG" que aparece 3 veces, "ACGG" que aparece 2 y "ACGT" que aparece 1, una llamada a <code>level(3)</code> dará como salida "ATG", "ACG" y "ACT", con sus frecuencias asociadas (3, 4 y 4, respectivamente).</p>
<h2><a class="anchor" id="problemaBiologia"></a>
Método 6 -&gt; float Distance(Nmer) : Aplicación del TDA Nmer a la caracterización del genoma de distintas especies.</h2>
<p>Una vez programado el TDA <a class="el" href="classNmer.html">Nmer</a> descrito en las secciones anteriores, proponemos que el estudiante aplique este TDA a un problema real: la identificación de especies en base a los Nmers de una secuencia de ADN. Para ello, se proporciona al estudiante extractos reales de longitud 10.000 de cadenas de ADN del genoma de 10 especies animales (ficheros <code>datos/1.txt</code>, <code>datos/2.txt</code>, ..., <code>datos/10.txt</code>). El estudiante debe construir un objeto <a class="el" href="classNmer.html">Nmer</a> para representar cada una de estas 10 secuencias de ADN. Una vez creados los Nmers, el estudiante deberá implementar una métrica para medir la distancia entre estos Nmers para identificar cuáles son las cadenas más parecidas entre sí. El fichero <code>datos/genomas disponibles.txt</code> muestra a qué especie corresponde cada cadena de ADN. Si los métodos están bien implementados y el tamaño de N es suficientemente elevado (recomendamos probar valores de N&gt;=10), los resultados deben ir acordes a la distancia evolutiva entre las especies [3]: por ejemplo, las cadenas humanas serán más parecidas entre sí o a las de ratón que a las de gusano. En cualquier caso, nuestros resultados pueden fluctuar dado que estamos considerando extractos de longitud reducida (10.000 bases es un tamaño reducido dado el tamaño total de los genomas considerados).</p>
<h3><a class="anchor" id="dist"></a>
Cálculo de la Distancia</h3>
<p>En esta sección detallaremos cómo se calcula la distancia entre dos Nmers. Para ello consideremos el siguiente ejemplo, donde calcularemos la distancia entre dos Nmers, nmX e nmY, construidos a partir de dos cadenas de ADN, adnX y adnY, respectivamente. Ilustraremos cómo sería al proceso para calcular: </p><div class="fragment"><div class="line">nmX.distance(nmY);</div></div><!-- fragment --><p>En nuestro caso, asumiremos que ambos datos tienen como longitud máxima 2. Si representamos los Nmers como una secuencia de pares <a class="el" href="classNmer.html">Nmer</a>=frecuencia:</p>
<ul>
<li>nmX: (A=690) (G=1019) (C=818) (T=694) (AA=199) (AG=282) (AC=99) (AT=109) (GA=257) (GG=372) (GC=231) (GT=159) (CA=153) (CG=162) (CC=284) (CT=219) (TA=81) (TG=202) (TC=204) (TT=207) </li>
<li>nmY: (A=985) (G=1202) (C=1262) (T=991) (AA=270) (AG=341) (AC=219) (AT=155) (GA=261) (GG=423) (GC=300) (GT=217) (CA=349) (CC=456) (CT=386) (TG=367) (TC=286) (TT=233)</li>
</ul>
<p>El primer paso consiste en ordenar los distintos Nmers de forma que los más frecuentes ocupen las primeras posiciones en el orden. Una alternativa para abordar este problema es utilizar un contenedor asociativo, tipo set, que almacene cada uno de los pares pero considerando como criterio de comparación el de mayor frecuencia. Como resultado tendríamos esta secuencia de elementos (<a class="el" href="classNmer.html">Nmer</a> frecuencia).</p>
<ul>
<li>nmX: G 1019;C 818;T 694;A 690;GG 372;CC 284;AG 282;GA 257;GC 231;CT 219;TT 207;TC 204;TG 202;AA 199;CG 162;GT 159;CA 153;AT 109;AC 99;TA 81; </li>
<li>nmY: C 1262;G 1202;T 991;A 985;CC 456;GG 423;CT 386;TG 367;CA 349;AG 341;GC 300;TC 286;AA 270;GA 261;TT 233;AC 219;GT 217;AT 155;</li>
</ul>
<p>Iterando sobre este contenedor es fácil asociar a cada <a class="el" href="classNmer.html">Nmer</a> su posición en el ranking. Así para adnX el <a class="el" href="classNmer.html">Nmer</a> G tendrá valor 1, <a class="el" href="classNmer.html">Nmer</a> C tendrá valor 2, <a class="el" href="classNmer.html">Nmer</a> T será 3, ... Esto es,</p>
<ul>
<li>rankingX: G 1; C 2; T 3; A 4; GG 5; CC 6; AG 7; GA 8; GC 9; CT 10; TT 11; TC 12; TG 13; AA 14; CG 15; GT 16; CA 17; AT 18; AC 19; TA 20; </li>
<li>rankingY: C 1; G 2; T 3; A 4; CC 5; GG 6; CT 7; TG 8; CA 9; AG 10; GC 11; TC 12; AA 13; GA 14; TT 15; AC 16; GT 17; AT 18;</li>
</ul>
<p>Una vez que tenemos este ranking podremos proceder a calcular la distancia teniendo en cuenta la distancia entre las posiciones en cada ranking. Así, por ejemplo G está a distancia 1 (diferencia entre 1 y 2), T está a distancia 0, TG está a distancia 5 (diferencia entre 13 y 8), ... y finalmente si consideramos tanto CG como TA diremos que están a distancia máxima (definida como la distancia máxima posible entre los rankings) ya que ambos Nmers no se encuentran en el rankingY.</p>
<p>Estas distancias (normalizadas) son acumuladas y debemos devolver el promedio.</p>
<p>El siguiente pseudo código nos permite computar dicha distancia: </p><div class="fragment"><div class="line">max &lt;- maximo(rankingX.size(),rankingY.size());</div><div class="line">dist &lt;- 0;</div><div class="line">Para cada <a class="code" href="classNmer.html">Nmer</a> n en rankingX {</div><div class="line">  Si (n pertenece a rankingY) {</div><div class="line">    posX &lt;- la posicion de n en rankingX</div><div class="line">    posY &lt;- la posicion de n en rankingY;</div><div class="line">    valor = abs(posX-posY)/max</div><div class="line">  } <span class="keywordflow">else</span> valor = 1;</div><div class="line">  dist+=valor;</div><div class="line">} </div><div class="line"><span class="keywordflow">return</span> dist/rankingX.<a class="code" href="classNmer.html#accdea65838fcd53c48a2d05f6809643f">size</a>() <span class="comment">// calculamos el promedio, tomando  valores en [0,1]</span></div></div><!-- fragment --><p>Finalmente, indicar que la distancia, tal y como está definida no es simétrica, esto es nmX.distance(nmY) != nmY.distance(nmX)</p>
<h1><a class="anchor" id="entrega"></a>
Entrega</h1>
<p>El alumno debe empaquetar todos los archivos relacionados con el proyecto en un archivo con nombre "genData.zip". Tenga en cuenta que no se incluirán ficheros objeto, ni ejecutables. Es recomendable que haga una "limpieza" para eliminar los archivos temporales o que se puedan generar a partir de los fuentes.</p>
<p>El alumno debe incluir un fichero con un main <code>src/ejemploNmer.cpp</code> que exhiba toda la funcionalidad programada para el TDA <a class="el" href="classNmer.html">Nmer</a>, incluyendo el cálculo de las distancias entre las 10 secuencias de distinta especie (<code>datos/1.txt, datos/2.txt</code>, etc).</p>
<p>El alumno ya tiene disponible un fichero Makefile para realizar la compilación. Conviene estudiar con detalle este fichero y sus distintas opciones:</p><ul>
<li><code>make</code> para generar los ejecutables</li>
<li><code>make documentacion</code> para generar la documentación en la carpeta <code>doc/html</code> y <code>doc/latex</code></li>
<li><code>make clean</code> para eliminar ficheros temporales y objeto.</li>
</ul>
<p>El alumno debe actualizar este fichero para compilar los nuevos módulos generados.</p>
<p>Tenga en cuenta que los archivos deben estar distribuidos en directorios:</p>
<p>genData.zip </p><ul>
<li>Makefile </li>
<li>include &ndash; Carpeta con ficheros de cabecera (.h) </li>
<li>src &ndash;Carpeta con código fuente (.cpp) </li>
<li>doc &ndash;Carpeta con Documentación </li>
<li>obj &ndash; Carpeta para código objeto (.o) </li>
<li>lib &ndash; Carpeta para bibliotecas (.a) </li>
<li>bin &ndash; Carpeta para ejecutables </li>
<li>datos &ndash; Carpeta para ficheros de datos</li>
</ul>
<p>La fecha límite de entrega es el día 25 de Enero de 2017 a las 23:59.</p>
<h1><a class="anchor" id="bibliografia"></a>
Bibliografía</h1>
<p>[1] k-mer en wikipedia: <a href="https://en.wikipedia.org/wiki/K-mer">https://en.wikipedia.org/wiki/K-mer</a></p>
<p>[2] Genomic DNA k-mer spectra: models and modalities. (2009) Benny Chor et al. Genome Biol. 10(10): R108.</p>
<p>[3] <a href="https://genome-euro.ucsc.edu/cgi-bin/hgGateway">https://genome-euro.ucsc.edu/cgi-bin/hgGateway</a> </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generado por &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
